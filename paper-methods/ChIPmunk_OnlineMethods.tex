\documentclass[12pt]{article}

% Imports
\usepackage{hyperref}
\usepackage[margin=0.5in]{geometry}
\usepackage{ctable}
\usepackage{array}
\usepackage{titlesec}
\usepackage{amsmath}

% Paragraph spacing
\setlength{\parindent}{0em}
\setlength{\parskip}{0.5em}

% Default font
\renewcommand*{\familydefault}{\sfdefault}

% title spacing
\titlespacing*{\section}
{0pt}{2pt}{0pt}
\titlespacing*{\subsection}
{0pt}{2pt}{0pt}

% table lines
\newcolumntype{?}{!{\vrule width 1pt}}

% hyperlinks
\hypersetup{
  breaklinks=true,  % so long urls are correctly broken across lines
  colorlinks=true,
  urlcolor=blue,
  linkcolor=red,
  citecolor=red,
 }

\begin{document}

%%% Notes %%%%
% * Put one sentence per line to make github track changes easier
% * Do not hard code references to figures, equations in this doc. use \ref{label} instead
\section*{Online Methods}

\subsection*{ChIPmunk model}

ChIPmunk models each major step (shearing, pulldown, PCR, and sequencing) of the ChIP-seq protocol (\textbf{Figure 1A, steps 1-4}) as a distinct module. It assumes binding sites for the target epitome are known, unlike other tools [refs] which focus on simulating binding sites themselves. Model parameters are summarized in \textbf{Table 1}.

\subsubsection*{1. Shearing}

In step 1, cross-linked DNA is sheared to a target fragment length, typically by sonication.
ChIPmunk models the length distribution of fragments.
We model fragment lengths using a gamma distribution (\textbf{Figure 1B}) based on empirical observation of fragment distributions which have long right tails (\textbf{Supplementary Figure 2}).
In the case of paired-end reads, fragment lengths can be determined trivially from the mapping locations of paired reads.
For single-end reads, individual fragment lengths are not directly observed. We outline a novel method for inferring summary statistics for the length distribution using single-end reads.

\paragraph{Inferring fragment lengths from paired-end reads}
The observed fragment length ($X_i$) for each read pair $i$ can be computed based on the mapping coordinates of the two reads.
The learn module randomly selects 10,000 read pairs from the input BAM for fitting a gamma distribution.
Read pairs are filtered to remove fragments marked as duplicates or secondary alignments. % TODO what about if not proper pair? and not mapping to same chrom?
Read pairs are further filtered to remove fragments with length greater than 3 times the median length of selected fragments.

The mean fragment length is easily computed as $\mu = \dfrac{\sum_{i=1}^{n}X_i}{n}$, where $n$ is the number of fragments remaining after filtering. We then use the method of moments to find maximum likelihood estimates of the gamma distribution shape ($k$) and scale parameters ($\theta$):

\begin{equation}
  k =  \dfrac{\mu}{\theta}
\end{equation}
\begin{equation}
  \theta = \dfrac{1}{n\mu}\sum_{i=1}^{n}(X_i - \mu)^2
\end{equation}

\paragraph{Inferring fragment lengths from single-end reads}
To estimate the fragment length distribution from single-end reads, we assume the length distribution follows gamma distribution with the mean $\mu$ and variance $v$, and use reads located inside ChIP-seq peaks (provided as input) to estimate $\mu$ and $v$ which are used to compute $k$ and $\theta$.

For each peak $peak_i$, we keep track of two lists, $\{start\}_{peak_i}$ and $\{end\}_{peak_i}$.
For each read overlapping $peak_i$, if the read is on the forward strand we add its start coordinate $\{start\}_{peak_i}$.
If the read is on the reverse strand we add its start coordinate to $\{end\}_{peak_i}$.
The center point of this peak is calculated as:

\begin{equation} \label{eq:center}
  center_{peak_i} = \frac{mean(\{start\}_{peak_i}) + mean(\{end\}_{peak_i})}{2}
\end{equation}
  
For every $peak_i$ we offset the coordinates in $\{start\}_{peak_i}$ and $\{end\}_{peak_i}$ by $center_{peak_i}$t, so that the coordinates of start points and end points are normalized and symmetric around zero.
We then concatenate lists from each peak to form $\{start\}$ and $\{end\}$:

\begin{equation} \label{eq:concat}
  \begin{array}{c}
  \{start\} = \oplus_{i=0}^{n} (\{start\}_{peak_i} - center_{peak_i})\\
  \{end\} = \oplus_{i=0}^{n} (\{end\}_{peak_i} - center_{peak_i})
  \end{array}
\end{equation}

The mean value of fragment length mu can be estimated as:
\begin{equation}
  \mu = mean(\{end\}) - mean(\{start\})
\end{equation}

We calculate the probability density functions, cumulative density functions and expected density functions for both $\{start\}$ and $\{end\}$.
The expected density function $EDF(x)$ is defined as the expected deviation of a random element in the list to $x$:
\begin{equation} \label{eq:EDF}
  \begin{array}{c} 
    EDF_{start}(x) = E(|S - x|) \\
    EDF_{end}(x) = E(|E - x|)
    \end{array}
\end{equation}
where $S$ is a random element in $\{start\}$ and $E$ is a random element in $\{end\}$.

Since we can compute $\mu$, we can reduce the density function of the fragment length distribution to $p_v(x)$. % TODO p_v(x) is the PDF. now just function of v and x.
We construct a score function $F(v)$ as shown below.
Intuitively, if we have a correct guess of $v$, $F(v)$ should be equal to zero.

\begin{equation}
  \begin{array}{c} \label{eq:Fv}
F(v) = E_v(|S + \frac{L}{2}|) + E_v(|E - \frac{L}{2}|) - E(|S + \frac{\mu}{2}|) + E(|E- \frac{\mu}{2}|) \\
E_v(|S + L/2|) = \sum_{x=0}^\infty p_v(x) * EDF_{start}(-\frac{x}{2}) \\
E_v(|E - L/2|) = \sum_{x=0}^\infty p_v(x) * EDF_{end}(\frac{x}{2}) \\
E(|S + \frac{\mu}{2}|)=EDF_{start}(x) \\
E(|E - \frac{\mu}{2}|)=EDF_{end}(x) \\
\end{array}
\end{equation}

To find an optimal $v$ that minimizes $|F(v)|$, we conduct a binary search between 1000 and 10,000.

In practice, we slightly offset the last two items in the score function in \textbf{Equation~\ref{eq:Fv}} to get the score below, which gave slightly more accurate estimation of $v$ on real data. This may be due to the fact that fragment length distributions are truncated on the left end, with little or no fragments with lengths less than 100bp observed, and thus do not follow a true gamma distribution.

\begin{equation}
F(v) = E_v(|S + \frac{L}{2}|) + E_v(|E - \frac{L}{2}|) - E(|S + \frac{\mu}{2} - \frac{E- \frac{\mu}{2}}{4}|) - E(|E- \frac{\mu}{2} - \frac{S + \frac{\mu}{2}}{4}|)
\end{equation}

\subsubsection*{Pulldown}
In step 2, sheared cross-linked DNA is subject to pulldown, during which an antibody for the protein or modification of interest is used to enrich the pool of fragments for those bound to the epitope recognized by the antibody.
This process is imperfect: some bound fragments will not be pulled down, and some unbound fragments will be pulled down.
To better model this process, we built the following formula to quantify the probability of pulldown for fragments in peak regions and also fragments in non-peak regions.

We use $B$ to represent if a random fragment is bound, and $\overline{B}$ if unbound. And we use $D$ to denote if a fragment is pulled down.
For any fragment, the probability of being pulled down is:
\begin{equation} \label{eq:pulldown}
    P(D) = P(D, B) + P(D, \overline{B}) = P(D|B)*P(B) + P(D|\overline{B})*P(\overline{B})
\end{equation}

In peak regions, due to the nature of ChIP-sequencing experiments, $P(D, B)$ is much greater than $P(D, \overline{B})$.
Thus, for fragment $i$ overlapped with peak $k$, the equation \textbf{Equation~\ref{eq:pulldown}} reduces to:
\begin{equation} \label{eq:pulldown_peak}
    P_i(D) \approx P_{ik}(D|B)*P_{ik}(B)
\end{equation}
For any fragment $i$, we assume that the probability of its being bound $P_{ik}(B)$ is directly proportional to the peak score $C_k$ with a coefficient $\alpha$, i.e. $P_{ik}(B) = \alpha*C_k$,
and once it is bound, the probability of its being pulled down is 100\%, i.e. $P_{ik}(D|B) = 1$.
Based users' choices, peak scores can either be based on peak intensities given in an input peak BED file or determined based on counts of overlapped fragments if a BAM file is specified.
If peak intensities are given, $C_k$ is defined as the intensity of peak $k$ divided by the maximum peak intensity.
If a BAM file is specified, $C_k$ is defined as the number of fragments overlapping peak $k$ divided by the maximum number of reads overlapping any peak.
This scaling ensures all peak scores are between 0 and 1. Thus for a fragment $i$ overlapped with peak $k$, the probability of its being pulled down is:
\begin{equation} \label{eq:pulldown_peak_in_practice}
P_i(D) \approx \alpha C_k
\end{equation}

For a fragment $j$ in a non-peak region, since the probability of its being bound is extremely small, we set $P_j(B) = 0$ and $P_j(\overline{B}) = 1$ as an approximation.
And we treat them uniformly with the same probability of pull-down, i.e. $P_{j}(D|\overline{B}) = P_{avg}(D|\overline{B})$.
Thus the equation \textbf{Equation~\ref{eq:pulldown}} reduces into:
\begin{equation} \label{eq:pulldown_nonpeak}
    P_j(D) \approx P_{avg}(D|\overline{B})
\end{equation}
To estimate the probability $P_{avg}(D|\overline{B})$, we model the ratio of the probabilities for a bound vs. an unbound fragment to be pulled down. Using Baye's Rule, we have:

\begin{equation} \label{eq:bayesPDB}
    P_{avg}(D|B) = \frac{P_{avg}(B|D)P_{avg}(D)}{P_{avg}(B)}
\end{equation}
\begin{equation} \label{eq:bayesPDUB}
    P_{avg}(D|\overline{B}) = \frac{P_{avg}(\overline{B}|D)P_{avg}(D)}{P_{avg}(\overline{B})}
\end{equation}

Taking the ratio of these cancels $P_{avg}(D)$ and gives:
\begin{equation} \label{eq:ratio}
  R = \frac{P_{avg}(D|B)}{P_{avg}(D|\overline{B})} = \frac{P(B|D)P_{avg}(\overline{B})}{P(\overline{B}|D)P_{avg}(B)}
\end{equation}

$P_{avg}(B)$, or the probability that a fragment is bound on average, is equal to the fraction of the genome bound by the factor of interest $f$.
We can approximate $f$ as the sum of the lengths of all peaks $l_k$ divided by the total length of the genome $T$.
We can approximate $f$ with \textbf{Equation~\ref{eq:avg_b}}, in which $l_k$ denotes the length of peak $k$ and this equation calculates the expected sum length of bound fragments divided by the total length of the genome $T$. Then we have $P(B) \approx f$ and $P(\overline{B}) \approx 1-f$.
\begin{equation} \label{eq:avg_b}
  f \approx \frac{1}{nT} \sum_{k=1}^{n} P_k(B) l_k \approx \frac{\alpha}{nT} \sum_{k=1}^{n} C_k l_k
\end{equation}


$P_{avg}(B|D)$, or the averaged probability that a fragment is bound given that it is pulled down, is a measure of the specificity of the antibody. This can be approximated by analyzing the percent of fragments falling within peaks, which we denote as $s$.
Thus $P_{avg}(B|D) \approx s$ and $P_{avg}(\overline{B}|D) \approx 1-s$.

Using these two metrics, $f$, and $s$ (\textbf{Supplementary Table 1}), we can simplify the ratio $R$ as:
\begin{equation} \label{eq:ratiosimple}
  R = \frac{s(1-f)}{(1-s)f}
\end{equation}

Combining all equations from \textbf{Equation~\ref{eq:pulldown_nonpeak}} to \textbf{Equation~\ref{eq:ratiosimple}} together, we can have the estimation of $P(D)$ for fragments in non-peak regions as is shown below:
\begin{equation} \label{eq:pulldown_nonpeak_in_practice_1}
P_j(D) \approx \frac{(1-s)f}{s(1-f)} * P_{avg}(D|B)
\end{equation}
Since we assume $P(D|B)$ is always equal to 1, \textbf{Equation~\ref{eq:pulldown_nonpeak}} can be further written as:
\begin{equation} \label{eq:pulldown_nonpeak_in_practice_2}
P_j(D) \approx \frac{(1-s)f}{s(1-f)}
\end{equation}

Because $f$ is very small in practice and proportional to the coefficient $\alpha$ in \textbf{Equation~\ref{eq:avg_b}}, $P_j(D)$ is also nearly proportional to $\alpha$ same as $P_i(D)$ of peak regions. Thus, the probability of pull-down is always proportional to $\alpha$ regardless of the fragment location, and we set $\alpha = 1$ in practice.

\subsubsection*{PCR}

In step 3, PCR is used to amplify pulled down fragments before sequencing.
Let $n_i$ represent the number of reads (or read pairs) with $i$ PCR duplicates (including the original fragment).
$n_i$ is modeled using a geometric distribution, where $r$ gives the probability that a fragment has no PCR duplicates.
The parameter $r$ is estimated as $1/\overline{n}$, where $\overline{n} = \frac{\sum_{i=1}^\infty (i * n_i)}{\sum_{i=1}^\infty n_i}$.

\subsubsection*{Sequencing}

In step 4, amplified fragments are subject to sequencing.
Sequences are based on an input reference genome using the coordinates of each fragment.
We model the per-base pair substitution rate, insertion rate, and deletion rate (\textbf{Supplementary Table 1}).

\subsection*{ChIPmunk implementation}

\subsubsection*{Learn implementation}
% TODO
% user input bam, bed, single vs. paired
% shearing for paired or single
% pulldown learn f or s
% PCR learn r. Require duplicates marked
% output as JSON format
Our learning module models read files, and generates parameters for 
(1) fragment length distribution, (2) pull-down efficiency, (3) PCR efficiency.
To estimate the fragment length distribution of an input read file,
our learning module chooses a modeling function based on the type of the read file (single-end or double-end reads),
and finds the best fit gamma distribution $Gamma (k, \theta)$.
To calculate pull-down efficiency, our learning module takes both the read file and the its peak file as input,
and returns the fraction of the genome bound by the factor of interest $f$ and the SPOT score $s$.
In the estimation of PCR efficiency, we scan through the read file, 
identify unique samples and the numbers of their PCR copies,
and fit them to a geometric distribution $Geo(p)$ with the number of PCR copies (including the original copy)
as x-axis and the number of samples falling into each bin as y-axis.
Itâ€™s noteworthy that this estimation step requires a BAM file with PCR copies flagged. Lastly, the learning module summarizes up all parameters, including $k$, $theta$, $f$, $s$ and $p$, and writes them into a json file with a user-specified path prefix.

\subsubsection*{Simulation implementation}
% TODO
% User inputs bed, optional BAM, model params

% Choose num copies. Separate sim per copy. discuss numcopies issue here

% For each copy:
% - Generate fragments, walking along chrom and choosing sizes from gamma distr
% - Decide based on overlap with peak whether to pull down
% - PCR on the pool of frags
% - Sequence

% Analyze one bin at a time for computational efficiency (how choose bin size, how deal with boundaries of bins)
% In practice, need to decide how many reads to generate from each chunk (see Michael's old pulldown text in scratch.tex)

\subsubsection*{C++ implementation details}
% TODO
% C++ implementation
% open source on github
% use standard open source libraries (htslib for BAM reading, pthread for multithreading)
% work with standard file formats (BED, BAM, jSON)
ChIPmunk is implemented using C++, and the its source code is publicly available on Github: https://github.com/gymreklab/ChIPmunk.
As input, it supports the standrad BAM file format, and two BED file formats including HOMER format and ENCODE BED format.

All analyses were performed using ChIPmunk v1.9. % TODO rerun with this one

\subsection*{Inferring parameters of ENCODE datasets}

We used the ENCODE Project's REST API to write a Python script to automatically identify available ChIP-sequencing for the GM12878 cell line.
We fetched unfiltered BAM files and narrowPeak or broadPeak peak files for transcription factors and histone modifications, respectively.
If multiple replicates were available for a factor, we chose the first one as a training example.
We chose a total of 221 datasets as examples.

We used the Picard \cite{picard} MarkDuplicates tool (v2.18.11) with default parameters to mark duplicates in each BAM file.
For paired end datasets, we called ChIPmunk's learn module with non-default parameter -{}-paired.
For single end datasets, we used non-default parameters -c 7 -{}-thres 100 for transcription factors and -c 7 -{}-thres 5 for histone modifications.
For 12 example paired-end datasets, we called learn in both paired end and single end mode to compare inferred fragment length distributions (\textbf{Supplementary Figure 2}).

Inferred parameters as well as links to JSON model files that can be used as input to the ChIPmunk simreads module are provided in \textbf{Supplementary Table 2}.

\subsection*{Evaluating ChIPmunk using ENCODE datasets}

We performed simulations using an increasing number of genome copies (ChIPmunk argument -{}-nc 1, 5, 10, 25, 50, 100, or 1000) for two factors (the histone modification H3K27ac and the transcription factor BACH1) with ENCODE data available in the GM12878 cell line.(BAM accession ENCFF097SQI and broadPeak [BED] accession ENCFF465WTH for H3K27ac; BAM accession ENCFF518TTP and narrowPeak [BED] accession ENCFF465WTH for BACH1.
For each copy number in each factor, we ran ChIPmunk's simreads tools on hg19 chromosome 19 (-{}-region chr19:1-59128983) using the corresponding learned ENCODE model (see \textbf{Supplementary Table 2}) and the same sequencing parameters as the ENCODE reads from chromosome 19 for each dataset (-{}-numreads 269113 -{}-readlen 51 for H3Ka7ac; -{}-numreads 665975 -{}-readlen 101 -{}-paired for BACH1). 
We additionally used options -p ENCODE.bed -t bed -c 7 -{}-scale-outliers, where ENCODE.bed represents the corresponding peak file for each factor with accessions listed above.
Simulated reads were aligned to the hg19 reference genome using BWA MEM \cite{bwamem} v0.7.12-r1039 with default parameters and converted to sorted and indexed BAM files using samtools \cite{samtools} version 1.5. Duplicates were flagged using the Picard \cite{picard} MarkDuplicates tool (v2.18.11) with default parameters.

We used the bedtools \cite{bedtools} (v2.27.1) makewindows command to generate a list of non-overlapping windows of 5kb across chromosome 19 and the bedtools multicov command to count the number of reads from each BAM file falling in each window. We used the bedtools intersect command to determine the intersection of each bin with the input peak files. For each bin, we determined the Pearson correlation bewteen log10 read counts in each simulated vs. the ENCODE dataset after removing bins with 0 counts in each dataset and adding a pseudocount of 1 read to each bin.

Timing experiments were performed in a Linux environment running Centos 7.4.1708 on a server with 28 cores (Intel\textsuperscript{\textregistered} Xeon\textsuperscript{\textregistered} CPU E5-2660 v4 @ 2.00GHz) and 125 GB RAM using the UNIX ``time'' command and are based on the ``sys'' time reported. % TODO should this be sys+user and performed on a single core?

%% TODO chipulate comparison %%

\subsection*{Power analysis}
% TODO Melissa

\subsection*{Analysis of spike in controls}
% TODO Melissa

\bibliography{ChIPmunk_OnlineMethods}
\bibliographystyle{ieeetr}

\end{document}

